// Code generated by protoc-gen-terraform. DO NOT EDIT.
// versions:
//   protoc-gen-gotf {{ .Version }}
// 	 protoc          {{ .ProtocVersion }}
// source: {{ .Location }}

package {{ .ProviderPackageName }}

import (
{{ if .Imports }}
	{{ .Imports | join "\n\t" }}
{{ end }}
)

// Ensure *{{ .Block.GoName }}DataSource fully satisfy terraform framework interfaces.
var _ datasource.DataSource = &{{ .Block.GoName }}DataSource{}

type {{ .Block.GoName }}DataSource struct {
	proxy dtsrc.Datasource
{{- range $name, $type := .Block.Members }}
	{{ $name }} {{ MemberType $type }} // defined in proto file
{{- end }}
}

func New{{ .Block.GoName }}DataSource(proxy dtsrc.Datasource) func() datasource.DataSource {
	if proxy == nil {
		panic("github.com/travix/gotf/dtsrc.Datasource is required")
	}
	return func() datasource.DataSource {
		return &{{ .Block.GoName }}DataSource{proxy: proxy}
	}
}

func (d *{{ .Block.GoName }}DataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .Block.TfName }}"
	if _proxy, ok := d.proxy.(dtsrc.CanMetadata); ok {
		ctx = d.setupContext(ctx)
		_proxy.Metadata(ctx, req, resp)
	}
}

func (d *{{ .Block.GoName }}DataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: {{ .Block.Description | quote }},
		Attributes: (&{{ .PbPackageName }}.{{ .Block.Model.Message.GoIdent.GoName }}{}).DatasourceSchema(),
	}
	if _proxy, ok := d.proxy.(dtsrc.CanSchema); ok {
		ctx = d.setupContext(ctx)
		_proxy.Schema(ctx, req, resp)
	}
}

func (d *{{ .Block.GoName }}DataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
{{- if .HasServiceClient }}
	// Get the gRPC client connection from the ProviderData
	if req.ProviderData == nil {
		resp.Diagnostics.AddError("Expected ProviderData to be not nil", "req.ProviderData is nil")
		return
	}
	conn, ok := req.ProviderData.(grpc.ClientConnInterface)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected ProviderData Type",
			fmt.Sprintf("Expected grpc.ClientConnInterface, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	// Create the service clients
	{{- range $name, $type := .Block.Members }}{{ if IsServiceClient $type }}
	d.{{ $name }} = {{ NewServiceClient $type }}(conn)
	{{- end }}{{- end }}
{{- end }}
	if _proxy, ok := d.proxy.(dtsrc.CanConfigure); ok {
		ctx = d.setupContext(ctx)
		_proxy.Configure(ctx, req, resp)
		return
	}
}

func (d *{{ .Block.GoName }}DataSource) ConfigValidators(ctx context.Context) []datasource.ConfigValidator {
	if _proxy, ok := d.proxy.(dtsrc.CanConfigValidators); ok {
		ctx = d.setupContext(ctx)
		return _proxy.ConfigValidators(ctx)
	}
	tflog.Warn(ctx, "ConfigValidators method not implemented. Make sure argument to New{{ .Block.GoName }}DataSource() implements dtsrc.CanConfigValidators interface")
	return nil
}

func (d *{{ .Block.GoName }}DataSource) ValidateConfig(ctx context.Context, req datasource.ValidateConfigRequest, resp *datasource.ValidateConfigResponse) {
	if _proxy, ok := d.proxy.(dtsrc.CanValidateConfig); ok {
		ctx = d.setupContext(ctx)
		_proxy.ValidateConfig(ctx, req, resp)
		return
	}
	tflog.Warn(ctx, "ValidateConfig method not implemented. Make sure argument to New{{ .Block.GoName }}DataSource() implements dtsrc.CanValidateConfig interface")
}

func (d *{{ .Block.GoName }}DataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data {{ .PbPackageName }}.{{ .Block.Model.Message.GoIdent.GoName }}
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
{{- if .HasServiceClient }}
	// Set the service clients into the context
	{{- range $name, $type := .Block.Members }}{{ if IsServiceClient $type }}
	ctx = cntxt.WithValue(ctx, {{ $name | quote }}, d.{{ $name }})
	{{ end }}{{- end }}
{{- end }}
	ctx = d.setupContext(ctx)
	diagnostics := d.proxy.Read(ctx, req, resp, &data)
	if diagnostics.HasError() {
		resp.Diagnostics.Append(diagnostics...)
		return
	}
	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (d *{{ .Block.GoName }}DataSource) setupContext(ctx context.Context) context.Context {
	// Pass members via context
	{{- if .HasServiceClient }}
	// also passes the service clients
	{{- end }}
{{- range $name, $type := .Block.Members }}
	ctx = cntxt.WithValue(ctx, {{ $name | quote }}, d.{{ $name }})
{{- end }}
	return ctx
}
