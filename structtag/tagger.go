package structtag

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"strings"
	"unicode"

	"golang.org/x/tools/go/ast/astutil"

	"github.com/rs/zerolog/log"
	"google.golang.org/protobuf/proto"

	"github.com/travix/protoc-gen-gotf/extension"
)

const mode = parser.AllErrors | parser.ParseComments

var (
	fset = token.NewFileSet()
)

type Tagger interface {
	Tag(file string, models []extension.Model) error
}

type tagger struct {
	tag     string
	replace *regexp.Regexp
}

func NewTagger(tag string) Tagger {
	return &tagger{tag: tag, replace: regexp.MustCompile(fmt.Sprintf(`%s:"[^"]+"`, tag))}
}

func (t *tagger) Tag(filePath string, models []extension.Model) error {
	astFile, err := parser.ParseFile(fset, filePath, nil, mode)
	if err != nil {
		return fmt.Errorf("failed to parse file %s: %w", filePath, err)
	}
	changed, apply := t.addTag(models)
	var ok bool
	astFile, ok = astutil.Apply(astFile, preApply(models), apply).(*ast.File)
	if !ok {
		return fmt.Errorf("failed to apply tagger to file %s", filePath)
	}
	if !*changed {
		return nil
	}
	for _, comment := range astFile.Comments {
		if strings.HasPrefix(comment.Text(), "Code generated by protoc-gen-go") {
			comment.List[len(comment.List)-1].Text += " // Modified by protoc-gen-gotf."
			break
		}
	}
	log.Debug().Msgf("modifying %s to add %s struct field tags", filePath, t.tag)
	var out bytes.Buffer
	if err = format.Node(&out, fset, astFile); err != nil {
		return fmt.Errorf("failed to format go content: %w", err)
	}
	var f *os.File
	if f, err = os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0); err != nil {
		return fmt.Errorf("failed to open file %s: %w", filePath, err)
	}
	if _, err = f.Write(out.Bytes()); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filePath, err)
	}
	if err = f.Close(); err != nil {
		return fmt.Errorf("failed to close file %s: %w", filePath, err)
	}
	return nil
}

func preApply(models []extension.Model) astutil.ApplyFunc {
	return func(cursor *astutil.Cursor) bool {
		if _, ok := cursor.Node().(*ast.File); ok {
			return true
		}
		decl, ok := cursor.Node().(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return false
		}
		var sExpr *ast.StructType
		var hasModel bool
		for _, spec := range decl.Specs {
			tspec, _ := spec.(*ast.TypeSpec)
			if sExpr, ok = tspec.Type.(*ast.StructType); !ok || sExpr.Fields.NumFields() <= 0 {
				continue
			}
			if _, ok = GetModel(models, tspec.Name.Name); ok {
				hasModel = true
			}
		}
		return hasModel
	}
}

func (t *tagger) addTag(models []extension.Model) (*bool, astutil.ApplyFunc) {
	changed := proto.Bool(false)
	// check if node is General Declaration and has an extension.Model
	// change struct field tags for all fields of struct that have a model
	apply := func(cursor *astutil.Cursor) bool {
		if _, ok := cursor.Node().(*ast.File); ok {
			return true
		}
		decl, _ := cursor.Node().(*ast.GenDecl)
		var ok bool
		var sExpr *ast.StructType
		var model extension.Model
		for _, spec := range decl.Specs {
			tspec, _ := spec.(*ast.TypeSpec)
			if sExpr, ok = tspec.Type.(*ast.StructType); !ok || sExpr.Fields.NumFields() <= 0 {
				continue
			}
			if model, ok = GetModel(models, tspec.Name.Name); !ok {
				continue
			}
			for _, field := range sExpr.Fields.List {
				if len(field.Names) == 0 || !unicode.IsUpper(rune(field.Names[0].Name[0])) {
					continue
				}
				tfsdkField := "-"
				if tfAttribute, has := model.FindAttribute(field.Names[0].Name); has {
					tfsdkField = tfAttribute.Name()
				}
				if field.Tag == nil {
					field.Tag = &ast.BasicLit{}
					field.Tag.Value = "`"
				} else {
					field.Tag.Value = strings.TrimSuffix(field.Tag.Value, "`")
					if strings.Contains(field.Tag.Value, fmt.Sprintf("%s:", t.tag)) {
						field.Tag.Value = strings.TrimSpace(t.replace.ReplaceAllString(field.Tag.Value, ""))
					}
					field.Tag.Value += " "
				}
				field.Tag.Value += fmt.Sprintf("%s:\"%s\"`", t.tag, tfsdkField)
				*changed = true
			}
		}
		return true
	}
	return changed, apply
}

func GetModel(models []extension.Model, typ string) (extension.Model, bool) {
	for _, m := range models {
		if m.Message().GoIdent.GoName == typ {
			return m, true
		}
	}
	return nil, false
}
